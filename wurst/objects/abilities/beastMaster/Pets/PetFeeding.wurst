package PetFeeding

// Standard library imports:
import ClosureEvents
import ClosuresForItems
import ChannelAbilityPreset
import Assets

// Third party imports:
import Lodash

// Local imports:
import LocalObjectIDs
import Pets
import ColorUtils
import StringExtensions
import HashMap
import LinkedList
import SimError
import TextTagUtils
import PetTaming
import ToolTipsUtils

/**
    Contains "Snack" spell abilityDefinition and the logic behind the pet mana handling
    A neutral animal can only be fed from "Food Throw" spell
    A tamed animal can feed upon nearby item using "Eat" spell
    I wanted animals to have different diet, but I fear it might add too much complexity for players or tooltipping
    Kinda want to be able to feed materials to drake based on their type (e.g red drake eats flint, nether eats darkness Orb)
**/

public let petDietMap = new HashMap<int, LinkedList<int>>()
    ..put(UNIT_ELK                        , asList(ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_TAMED_ELK                  , asList(ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_JUNGLE_WOLF                , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_TAMED_WOLF                 , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_TAMED_BEAR                 , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_JUNGLE_BEAR                , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_HAWK_HATCHLING             , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_TAMED_HAWK                 , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_ACORN, ITEM_MAGIC_ACORN))
    ..put(UNIT_CORROSIVE_DRAGON_HATCHLING , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_POISON, ITEM_ULTRA_POISON))
    ..put(UNIT_CORROSIVE_DRAGON           , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_POISON, ITEM_ULTRA_POISON))
    ..put(UNIT_FIRE_DRAGON_HATCHLING      , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_FIRE_BOMB))
    ..put(UNIT_FIRE_DRAGON                , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_FIRE_BOMB))
    ..put(UNIT_FROST_DRAGON_HATCHLING     , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_SPIRIT_WATER))
    ..put(UNIT_FROST_DRAGON               , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_SPIRIT_WATER))
    ..put(UNIT_STORM_DRAGON_HATCHLING     , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_SPIRIT_WIND))
    ..put(UNIT_STORM_DRAGON               , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_SPIRIT_WIND))
    ..put(UNIT_NETHER_DRAGON_HATCHLING    , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_SPIRIT_DARKNESS))
    ..put(UNIT_NETHER_DRAGON              , asList(ITEM_COOKED_MEAT, ITEM_HAWK_EGG, ITEM_SPIRIT_DARKNESS))


public let foodMapMana = new HashMap<int, int>()
    ..put(ITEM_COOKED_MEAT     , 3)
    ..put(ITEM_ACORN           , 4)
    ..put(ITEM_HAWK_EGG        , 6)
    ..put(ITEM_MAGIC_ACORN     , 8)
    ..put(ITEM_POISON          , 10)
    ..put(ITEM_ULTRA_POISON    , 20)
    ..put(ITEM_FIRE_BOMB       , 10)
    ..put(ITEM_FLINT           , 8)
    ..put(ITEM_SPIRIT_WATER    , 20)
    ..put(ITEM_SPIRIT_WIND     , 20)
    ..put(ITEM_SPIRIT_DARKNESS , 20)

public let FOODS_TT = map((food, _) -> food.color(HIGHLIGHT_COLOR), asList(
                    "Cooked Meat " + foodMapMana.get(ITEM_COOKED_MEAT).toString(),
                    "Acorn "       + foodMapMana.get(ITEM_ACORN      ).toString(),
                    "Magic Acorn " + foodMapMana.get(ITEM_MAGIC_ACORN).toString()
                    )).joinBy(", ")

let TOOLTIP = "Snack"
let TOOLTIP_EXT = "Gains mana by ingesting the nearest edible item."
                  + "\nFollowing items are considered edible and give mana, format being " + "#Item #Mana".color(HIGHLIGHT_COLOR) + " gained :\n"
                  + FOODS_TT + ".\n\n"
                  + "Note: Elk do not eat Meat".color(COLOR_RED)


@compiletime function createAbilitySnackItemPet() returns ChannelAbilityPreset
    return new ChannelAbilityPreset(ABILITY_PET_SNACK, 1, true)
        ..setManaCost(1, 0)
        ..setCastRange(1, 9999)
        ..presetTargetTypes(Targettype.NONE)
        ..setIconNormal(Icons.bTNCannibalize)
        ..setButtonPositionNormalX(1)
        ..setButtonPositionNormalY(1)
        ..setCooldown(1, 1)
        ..setName(TOOLTIP)
        ..setTooltipNormal(1, makeToolTipNorm("S", TOOLTIP))
        ..setTooltipNormalExtended(1, TOOLTIP_EXT)
        ..setEditorSuffix("(Wurst)")
        ..presetOption(Option.VISIBLE, true)

public function feedPet(unit pet, unit caster, int itemId, int _charges)
    var charges = _charges
    if charges == 0
        charges = 1

    let manaFromStack = (charges * foodMapMana.get(itemId)).toReal()
    let totalMana = pet.getMana() + manaFromStack

    let manaExcess = totalMana - pet.getMaxMana()
    let correctAmount = manaExcess > 0
                               ? manaFromStack - (manaExcess)
                               : manaFromStack

    pet.addMana(correctAmount)

    // Create a text tag to visualize the effect.
    if correctAmount > 0
        createTeamFadingTextTag(caster, pet.getPos3Real(), "+" + correctAmount.floor().toString(), COLOR_TURQUOISE)
        flashEffect(Abilities.aImaTarget, pet, "origin")

    if manaExcess >= 0

        // If the animal reach max mana and is neutral, add him as a pet
        if pet.getOwner() == players[PLAYER_NEUTRAL_AGGRESSIVE] or pet.getOwner() == players[PLAYER_NEUTRAL_PASSIVE]
            if caster.getOwner().getPet() == null
            // Could allow pet stealing.... might be funny...
            // or u.getOwner().isEnemyOf(caster.getOwner())
                tamePet(caster.getOwner(), pet)
            else
                simError(caster.getOwner(), "Cannot tame more pet")
        else
            simError(caster.getOwner(), "This pet is full")

        // In case there's too much food sent, we create an item stack with the remaining charges
        // We could actually compute the remaning charges before and send the exact number needed, but I imagine funny
        // situation will come out of this behavior
        // Using floor to make sure atleast 1 charge is consumed
        let leftover = ((manaExcess) / foodMapMana.get(itemId)).floor()
        if leftover > 0
            createItem(itemId, pet.getPos())..setCharges(leftover)

function onSnack(unit caster)
    let nearestFood = findNearestItem(caster.getPos(), 250, i -> petDietMap.get(caster.getTypeId()).has(i.getTypeId()))

    if caster.getMissingMana() == 0
        simError(caster.getOwner(), "This pet cannot eat anymore")
    else if nearestFood != null
        caster.setFacing(caster.getPos().angleTo(nearestFood.getPos()))
        feedPet(caster, caster, nearestFood.getTypeId(), nearestFood.getCharges())
        nearestFood.remove()
    else
        simError(caster.getOwner(), "There's nothing edible for this pet to eat")

init
    EventListener.onCast(ABILITY_PET_SNACK, (unit caster) -> onSnack(caster))
