package ResourceSpawnsUtils

import Composer

// Standard library imports:
import ErrorHandling
import HashMap
import Interpolation
import TerrainUtils

// Third-party imports:
import Lodash
import LodashExtensions

// Local imports:
import Game
import GameConfig
import GeometryUtils
import Pool

// The maximum number of tries when selecting a random point.
@configurable let MAX_TRIES = 1000

function getRandomAllowedPoint(Pool<rect> allowed, region blocked) returns vec2
    // Pick a random region.
    let spawnRect = allowed.random()

    // Attempt to pick a random, valid point.
    for index = 0 to MAX_TRIES
        // Pick a point.
        let spawnPoint = spawnRect.randomPoint()

        // Output the point if it is valid.
        if (
            spawnPoint.isTerrainLand()
            and spawnPoint.isTerrainWalkable()
            and not spawnPoint.isInRegion(blocked)
        )
            return spawnPoint

    // Fail if no valid point was able to be found.
    // TODO: Use logging once set up.
    error("Max iteration count reached in searching for an allowed spawn point")

    // Output a dummy result.
    return vec2(0,0)

public class Spawner
    Composer fn

    construct(Composer fn)
        this.fn = fn

    function spawn()
        this.fn.execute()

public class ItemSpawnComposer implements Composer
    protected ItemPool items
    protected Pool<rect> allowed
    protected region blocked

    construct(ItemPool items, Pool<rect> allowed, region blocked)
        this.items = items
        this.allowed = allowed
        this.blocked = blocked

    override function execute()
        let spawnPoint = getRandomAllowedPoint(this.allowed, this.blocked)
        let spawnItemId = this.items.random()
        createItem(spawnItemId, spawnPoint)
        items.register(spawnItemId)

public class FishSpawnComposer implements Composer
    protected Pool<int> units
    protected rect allowedRegion

    construct(Pool<int> units, rect allowedRegion)
        this.units = units
        this.allowedRegion = allowedRegion

    override function execute()
        // Spawn a unit with a random type and location.
        createUnit(
            players[PLAYER_NEUTRAL_AGGRESSIVE],
            this.units.random(),
            this.allowedRegion.randomPoint(),
            randomAngle()
        )

public class AnimalSpawnComposer implements Composer
    protected Pool<int> units
    protected Pool<rect> allowed
    protected region blocked

    construct(Pool<int> units, Pool<rect> allowed, region blocked)
        this.allowed = allowed
        this.blocked = blocked
        this.units = units

    override function execute()
        // Spawn a unit with a random type and location.
        createUnit(
            players[PLAYER_NEUTRAL_AGGRESSIVE],
            this.units.random(),
            getRandomAllowedPoint(this.allowed, this.blocked),
            randomAngle()
        )

public class IslandInfo
    int itemsSpawnCount
    int animalsSpawnCount
    Pool<rect> spawnRegionsPool

    construct(int itemsSpawnCount, int animalsSpawnCount, Pool<rect> spawnRegionsPool)
        this.itemsSpawnCount = itemsSpawnCount
        this.animalsSpawnCount = animalsSpawnCount
        this.spawnRegionsPool = spawnRegionsPool

// This class computes how rates change over time, allowing for spawn rates to
// increase or decrease as the game progresses.
public class WeightScaler
    // The initial value for the weight.
    real first

    // The final value for the weight.
    real final

    // The number of seconds it takes to move the weight between the two.
    real delta

    // Simply copy the parameters when constructing.
    construct(real first, real final, real delta)
        this.first = first
        this.final = final
        this.delta = delta

    function getTimeAdjustedSpawnWeight() returns real
        // Compute how far along the line the current value is.
        let ratio = this.delta == 0
            // Avoid division by zero and simply move to the end.
            ? 1
            // Avoid extrapolation.
            : (GAME_TIMER.getElapsed() / this.delta).clamp(0, 1)

        // Interpolate between the initial and final values.
        return linear(ratio, final, delta)

public class WeightedPool<V> extends Pool<V>
    protected IterableMap<V, WeightScaler> weights

    construct(IterableMap<V, WeightScaler> weights)
        this.weights = weights

    function update()
        this.totalWeight = 0
        this.options.flush()

        for key in this.weights
            let weightScaler = this.weights.get(key)
            this.add((weightScaler.getTimeAdjustedSpawnWeight() * gameConfig.getHostileSpawnRate()).ceil(), key)

// This class acts as a pool that will automatically adjust weights to balance
// spawn rates expected values against their actual values.
public class ItemPool extends Pool<int>
    // The weight scaler per item type in the pool.
    private OwnedIterableMap<int, WeightScaler> weights

    // The expected total amount of spawns per item.
    private let expectedTotals = new HashMap<int, real>()

    // The actual total amount of spawns per item.
    private let actualTotals = new HashMap<int, int>()

    // The number of items created per interval.
    int itemsSpawnCount

    construct(IterableMap<int, WeightScaler> weights, int itemsSpawnCount)
        this.itemsSpawnCount = itemsSpawnCount

        // Copy or reference the weights, as appropriate.
        if weights instanceof OwnedIterableMap<int, WeightScaler>
            this.weights= weights castTo OwnedIterableMap<int, WeightScaler>
        else
            this.weights = weights.own()

    // Adjusts the weight for each item as follows:
    // 1. Compute the ratio between the expected and actual totals.
    // 2. Clamp the ratio within (0.5, 1.5) to avoid drastic adjustments.
    // 3. Translate that interval to (0.2, -0.2), the proportional change.
    // 4. Scale the current weight by that proportion.
    // For example, consider the following:
    // 1. Let weight = 20, expected = 15, actual = 25.
    // 2. Therefore ratio = 1.66 -> 1.5 and so proportional change = -0.2.
    // 3. The new weight is 16.
    // A second is as follows:
    // 1. Let weight = 20, expected = 15, actual = 12.
    // 2. Therefore ratio = 0.8 and so proportional change = 0.08.
    // 3. The new weight is 21.6.
    function computeDelta(int id) returns real
        // Look up the expected total, which defaults to zero initially.
        let expected = expectedTotals.get(id)

        // Look up the current total, which defaults to zero initially.
        let actual = actualTotals.get(id)

        // Avoid division by zero and make no adjustment initially.
        let ratio = (expected != 0 ? actual / expected : 1.)

        // Compute the proportion by which the weight will be adjusted.
        return 0.2 * (1 - ratio).clamp(-0.5, 0.5) / 0.5

    // Increments the state by adjusting the weight for all tracked items.
    function increment()
        // Compute the current weight for each item.
        let currentWeights = weights
            .map((id, weight) -> weight.getTimeAdjustedSpawnWeight())
            .own()

        // Compute the sum of all current weights.
        let totalWeight = currentWeights.sum()

        // Update the weight for each entry.
        for id in weights
            // TODO: Don't round once the pool can support decimal weights.
            update(
                (currentWeights.get(id) * (1 + computeDelta(id))).round(),
                id
            )

        // Update the expected total for each entry.
        for id in this.weights
            // Compute the share of items that are of this type.
            let share = currentWeights.get(id) / totalWeight

            // Compute the expected amount of new spawns of this type.
            let delta = share * (itemsSpawnCount * gameConfig.getItemBase())

            // Increment the expected total.
            expectedTotals.put(id, expectedTotals.get(id) + delta)

    // Records that an item of the given type was spawned.
    function register(int id)
        actualTotals.put(id, actualTotals.get(id + 1))
