package TradeShipSupervisor

// Standard library imports:
import Assets
import ClosureEvents
import ClosureTimers
import ErrorHandling
import HashMap
import LinkedList
import Orders

// Local imports:
import LocalAssets
import PingMinimap
import TradeShipStop

let TRADE_SHIP_PAUSE_TIME_DEST = 0
let TRADE_SHIP_PAUSE_TIME_SELL = 0

public interface TradeShipListener
    function run(TradeShipSupervisor ship)

public enum TradeShipSupervisorState
    MOVING
    STOPPED
    EXITED

public class TradeShipSupervisor
    static let ships = new HashMap<unit, thistype>()
    static let whenEnterRegion = CreateTrigger()
        ..registerEnterRegion(TradeShipStop.tradeStops, null)
        ..addAction(function TradeShipSupervisor.handleEnterRegion)

    unit ship
    unit dummy
    bool orderListenerEnabled = true
    TradeShipStop firstStop
    TradeShipStop nextStop
    CallbackPeriodic callback
    var state = TradeShipSupervisorState.STOPPED
    let listeners = new LinkedList<TradeShipListener>()
    var numForksReached = 0

    static function handleEnterRegion()
        let enteringUnit = GetEnteringUnit()
        if ships.has(enteringUnit)
            ships.get(enteringUnit).processEnterRegion()

    construct(TradeShipStop firstStop, int shipId)
        // Look up the next stop in order to place the ship facing it.
        nextStop = firstStop.getNext()

        // Create the ship.
        ship = createUnit(
            players[0],
            shipId,
            firstStop.getPos(),
            firstStop.getPos().angleTo(nextStop.getPos())
        )

        // Create the dummy unit used to display the gold mine minimap icon.
        dummy = createUnit(
            players[PLAYER_NEUTRAL_PASSIVE],
            LocalUnitIds.dummyGoldMine,
            firstStop.getPos(),
            firstStop.getPos().angleTo(nextStop.getPos())
        )

        // Disable the pathing to prevent players from blocking the ship.
        ship.setPathing(false)

        // Update the location of the dummy to match the ship periodically.
        doPeriodically(1.) (CallbackPeriodic cb) ->
            dummy.setXY(ship.getPos())

        // Register the unit for later listeners.
        ships.put(ship, this)

        // Begin the trade route.
        moveToNextStop()

        // Prevent players from issuing orders using the shared control glitch.
        EventListener.add(ship, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER) ->
            onIssuedOrder()
        EventListener.add(ship, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER) ->
            onIssuedOrder()
        EventListener.add(ship, EVENT_PLAYER_UNIT_ISSUED_ORDER) ->
            onIssuedOrder()

    function onIssuedOrder()
        if not this.orderListenerEnabled
            return
        if GetIssuedOrderId() != OrderIds.smart and GetIssuedOrderId() != OrderIds.move
            return
        this.orderListenerEnabled = false
        switch state
            case MOVING
                let orderId = GetIssuedOrderId()
                let targetPos = EventData.getOrderPos()
                let nextStopPos = nextStop.getPos()
                print("Issuing order")
                pingMinimap(nextStop.getPos())
                if orderId != Orders.move or targetPos.distanceToSq(nextStopPos) > 10000.0
                    ship.issuePointOrder("move", nextStopPos)
            case STOPPED
                ship.issueImmediateOrder("stop")
            case EXITED
                skip
        this.orderListenerEnabled = true

    function getState() returns TradeShipSupervisorState
        return state

    function addListener(TradeShipListener listener)
        listeners.add(listener)

    function triggerListeners()
        listeners.forEach(listener -> listener.run(this))

    function moveToNextStop()
        // Exit if the ship is already moving.
        if state == TradeShipSupervisorState.MOVING
            return

        state = TradeShipSupervisorState.MOVING
        // Enable order for this ship so that it may be move.
        this.orderListenerEnabled = false
        ship.issuePointOrder("move", nextStop.getPos())
        print("Issuing order")
        pingMinimap(nextStop.getPos())
        this.orderListenerEnabled = true
        destroyCallback()

        callback = doPeriodically(1.0) cb ->
            this.orderListenerEnabled = false
            ship.issuePointOrder("move", nextStop.getPos())
            this.orderListenerEnabled = true

    function pause(real duration)
        // Exit if the ship is already stopped.
        if state == TradeShipSupervisorState.STOPPED
            return

        state = TradeShipSupervisorState.STOPPED
        destroyCallback()
        doAfter(duration, -> moveToNextStop())

    function removeShip()
        ships.remove(ship)
        dummy.remove()
        ship.remove()
        state = TradeShipSupervisorState.EXITED
        destroy callback
        ship = null

    function setNextStop()
        if nextStop.hasFork() and numForksReached > 3
            nextStop = nextStop.getFork()
        else
            numForksReached++
            nextStop = nextStop.getNext()

    private function processEnterRegion()
        if not nextStop.isInStopRange(ship)
            return

        if nextStop.isLastStop()
            removeShip()
        else
            pause(nextStop.getPauseTime())
            setNextStop()

        triggerListeners()

    private function destroyCallback()
        if callback != null
            destroy callback
            callback = null

    ondestroy
        for listener in listeners
            destroy listener
        destroy listeners

        if ship != null
            removeShip()
            error("TradeShipSupervisorError: destroyed while ship not null")
