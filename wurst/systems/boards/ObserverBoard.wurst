package ObserverBoard
import LinkedList
import Tribe
import GameMode
import PlayerExtensions
import PublicLibrary
import StringUtils
import RegisterEvents
import Boards
import ClosureTimers

let OPTION_NAME_COLOR = colorA(180, 180, 180, 255)
let OPTION_VALUE_COLOR = colorA(115, 152, 255, 255)
let OPTION_VALUE_SELECTED_COLOR = colorA(47, 32, 255, 255)

abstract class ObserverBoardControl
    string name
    player whichPlayer

    construct(string name, player whichPlayer)
        this.name = name
        this.whichPlayer = whichPlayer

    function getName() returns string
        return name

    abstract function getInitialValue() returns string
    abstract function onRight() returns string
    abstract function onLeft() returns string

class ObserverBoardVisionControl extends ObserverBoardControl
    LinkedList<string> options
    LLIterator<string> iterator
    var currentValue = "players"

    construct(player whichPlayer)
        super("Vision", whichPlayer)
        options
            ..add("players")
            ..add("all")

        iterator = options.iterator()

        for tribe in Tribe.getTribes()
            options.add("tribe " + (tribe.getId() + 1).toString())

    function onSelect()
        switch currentValue
            case "players"
                for i = 0 to bj_MAX_PLAYERS - 1
                    whichPlayer.setPlayerAlliance(players[i], ALLIANCE_SHARED_VISION, true)
            case "all"
                for i = 0 to bj_MAX_PLAYERS - 1
                    whichPlayer.setPlayerAlliance(players[i], ALLIANCE_SHARED_VISION, true)
            default
                let tribeId = currentValue.split(" ").get(1).toInt()
                for i = 0 to bj_MAX_PLAYERS - 1
                    let tribe = Tribe.ofPlayer(players[i])
                    let share = tribe != null and tribe.getId() == tribeId
                    whichPlayer.setPlayerAlliance(players[i], ALLIANCE_SHARED_VISION, share)

    override function getInitialValue() returns string
        return iterator.next()

    override function onRight() returns string
        if not iterator.hasNext()
            iterator.reset()
        currentValue = iterator.next()
        return currentValue

    override function onLeft() returns string
        return currentValue

class ObserverBoardZoomControl extends ObserverBoardControl
    static let MAX = 1500

    var currentValue = 0

    construct(player whichPlayer)
        super("Zoom", whichPlayer)
        currentValue = ZOOM_DISTANCE[whichPlayer.getId()].toInt()

    function onSelect()
        ZOOM_DISTANCE[whichPlayer.getId()] = currentValue.toReal()

    override function getInitialValue() returns string
        return currentValue.toString()

    override function onRight() returns string
        currentValue = (currentValue + 100) mod MAX
        return currentValue.toString()

    override function onLeft() returns string
        currentValue = (currentValue + MAX - 100) mod MAX
        onSelect()
        return currentValue.toString()

class ObserverBoard
    static let boards = new HashMap<player, thistype>()

    static function onDown()
        let p = GetTriggerPlayer()
        if boards.has(p)
            boards.get(p).onArrowDown()

    static function onUp()
        let p = GetTriggerPlayer()
        if boards.has(p)
            boards.get(p).onArrowUp()

    static function onRight()
        let p = GetTriggerPlayer()
        if boards.has(p)
            boards.get(p).onArrowRight()

    static function onLeft()
        let p = GetTriggerPlayer()
        if boards.has(p)
            boards.get(p).onArrowLeft()

    player observer
    LinkedList<ObserverBoardControl> options
    let board = CreateMultiboard()
    var selected = 0

    construct(player observer, LinkedList<ObserverBoardControl> options)
        this.observer = observer
        this.options = options

        board
            ..setColumnCount(2)
            ..setRowCount(options.size())
            ..display(observer, true)

        var row = 0
        for option in options
            board
                .getItem(row, 0)
                ..setValue(option.getName())
                ..setValueColor(OPTION_NAME_COLOR)
                ..release()

            board
                .getItem(row, 1)
                ..setValue(option.getInitialValue())
                ..setValueColor(OPTION_VALUE_COLOR)
                ..release()

        board
            .getItem(0, 1)
            ..setValueColor(OPTION_VALUE_SELECTED_COLOR)

        doPeriodically(1, cb -> board.setTitle(getGameTimersBoardTitle()))

    function onArrowLeft()
        options
            .get(selected)
            .onLeft()

    function onArrowRight()
        options
            .get(selected)
            .onRight()

    function onArrowUp()
        board
            .getItem(selected, 1)
            ..setValueColor(OPTION_VALUE_COLOR)
            ..release()

        let size = options.size()
        selected = (selected - 1 + size) mod size

        board
            .getItem(selected, 1)
            ..setValueColor(OPTION_VALUE_SELECTED_COLOR)
            ..release()

    function onArrowDown()
        board
            .getItem(selected, 1)
            ..setValueColor(OPTION_VALUE_COLOR)
            ..release()

        let size = options.size()
        selected = (selected + 1) mod size

        board
            .getItem(selected, 1)
            ..setValueColor(OPTION_VALUE_SELECTED_COLOR)
            ..release()

function getObservers() returns LinkedList<player>
    let observers = new LinkedList<player>()
    for i = 0 to bj_MAX_PLAYERS - 1
        let current = players[i]
        if current.isObserver() and current.isIngame()
            observers.add(current)
    return observers

init
    GameMode.onModeSelectionFinish() ->
        let observers = getObservers()
        for observer in observers
            let options = asList<ObserverBoardControl>(
                new ObserverBoardVisionControl(observer),
                new ObserverBoardZoomControl(observer)
            )
            new ObserverBoard(observer, options)

        if observers.size() > 0
            registerPlayerEvent(EVENT_PLAYER_ARROW_DOWN_DOWN, function ObserverBoard.onDown)
            registerPlayerEvent(EVENT_PLAYER_ARROW_UP_DOWN, function ObserverBoard.onUp)
            registerPlayerEvent(EVENT_PLAYER_ARROW_RIGHT_DOWN, function ObserverBoard.onRight)
            registerPlayerEvent(EVENT_PLAYER_ARROW_LEFT_DOWN, function ObserverBoard.onLeft)

        destroy observers
