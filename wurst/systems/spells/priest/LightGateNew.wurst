package LightGateNew
import RegisterEvents
import HashMap
import LinkedList
import ClosureTimers
import Orders
import ClosureForGroups
import DummyCaster
import Pool

constant let ABILITY_ID = 'A01H'
constant let GROW_DURATION = 10.
constant let MINIMUM_GROW_DURATION = 1.5
constant let DURATION_MAX = 40.
constant let ORB_COUNT = 7
constant let ORB_LOOP_INTERVAL = 0.03125
constant let ORB_ANGULARSPEED_SUMMON = 80.
constant let ORB_ANGULARSPEED_ACTIVE = 10.
constant let SPELLCAST_INTERVAL_FASTEST = 2.
constant let SPELLCAST_INTERVAL_START = 3.
constant let PORTAL_GROWSPEED = 100.
constant let SPELLCAST_EFFECT_PATH = "Abilities\\Spells\\Human\\HolyBolt\\HolyBoltSpecialArt.mdl"
constant let ORB_EFFECT_PATH = "Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"

let lightGateInstances = new HashMap<unit, LightGateInstance>()
let spellPool = new Pool<OrbSpell>()

class OrbSpell
    int spellId
    int orderId
    int checkBuff
    string name
    construct(string name, int spellId, int orderId, int checkBuff)
        this.spellId = spellId
        this.orderId = orderId
        this.name = name
        this.checkBuff = checkBuff

class PortalOrb
    LightGateInstance instance
    effect orbFX = null
    vec3 pos

    construct (LightGateInstance portal, vec3 startPos)
        instance = portal
        pos = startPos
        orbFX = addEffect(ORB_EFFECT_PATH, startPos)
        orbFX.setScale(2)

    function setPos(vec3 newpos)
        pos = newpos
        orbFX.setPos(pos)

    function setFacing(angle facing)
        orbFX.setRoll(facing)

    function castRandomSpell(unit target) returns bool
        var owner = instance.ownerUnit.getOwner()
        OrbSpell randomSpell = spellPool.random()
        if randomSpell.checkBuff != 0 //If target already has the buff of a buff spell, dont cast it
            if target.hasAbility(randomSpell.checkBuff)
                return false

        let caster = new DummyCaster()
            ..owner(owner)
            ..origin(this.pos.toVec2())
        let dummy = caster.castTarget(randomSpell.spellId, 1, randomSpell.orderId, target)
        if dummy != null
            addEffect(SPELLCAST_EFFECT_PATH, this.pos).destr()
            return true
        return false

    ondestroy
        instance.orbs.remove(this)
        orbFX.destr()

public class LightGateInstance
    angle orbAngle
    unit ownerUnit
    bool isChanneling
    real portalRadius
    real elapsedLifetime
    real channeledTime
    real lastSpellCastTimestamp
    real spellIntervalCurrent
    real durationBuildup
    vec3 centerPos
    CallbackCounted portalActiveLoop = null
    CallbackCounted portalCreationLoop = null
    LinkedList<PortalOrb> orbs = new LinkedList<PortalOrb>()

    construct (unit caster, vec3 pos)
        ownerUnit = caster
        isChanneling = true
        portalRadius = 50
        centerPos = pos
        elapsedLifetime = 0
        channeledTime = 0
        durationBuildup = 0
        lastSpellCastTimestamp = -9999
        orbAngle = angle(0)
        spellIntervalCurrent = SPELLCAST_INTERVAL_START
        startPortalCreation()

    function startPortalCreation()
        for i = 1 to ORB_COUNT
            orbs.push(new PortalOrb(this, centerPos))

        portalCreationLoop = doPeriodicallyTimed(ORB_LOOP_INTERVAL, GROW_DURATION) portalGrowLoop ->
            if not isChanneling or portalGrowLoop.isLast()
                portalGrowLoop.stop()
                this.startPortalLoop()
            else
                portalGrowLoopUpdate()

    function portalGrowLoopUpdate()
        //Avoid creating vision on every loop cycle with mod check
        if (portalCreationLoop.getCount() mod 30 == 0)
            var vis = createVision(ownerUnit.getOwner(), centerPos.toVec2(), portalRadius+256, true)
            vis.start()
            //Should be the full duration of portal calculated below for vision mods destruction
            doAfter(durationBuildup + GROW_DURATION - elapsedLifetime) ->
                vis.destr()

        //Update things that change with channeling time
        spellIntervalCurrent = SPELLCAST_INTERVAL_START - (SPELLCAST_INTERVAL_START - SPELLCAST_INTERVAL_FASTEST) * (elapsedLifetime/GROW_DURATION)
        elapsedLifetime += ORB_LOOP_INTERVAL
        channeledTime += ORB_LOOP_INTERVAL
        portalRadius += ORB_LOOP_INTERVAL * PORTAL_GROWSPEED
        durationBuildup = (channeledTime / GROW_DURATION) * DURATION_MAX
        orbAngle = angle(orbAngle.radians() + ORB_LOOP_INTERVAL * ORB_ANGULARSPEED_SUMMON * DEGTORAD)

        //Move orbs around
        updateOrbAngles()

    function randomOrbCastSpell()
        var orb = this.orbs.get( GetRandomInt(0, orbs.size() - 1))
        var centerPosVec2 = centerPos.toVec2()

        //Find random target and cast + spawn effect on orb
        let targets = CreateGroup()..enumUnitsInRange(centerPosVec2, portalRadius)
        targets.forEachIn(u -> begin
            if not isValidTarget(u)
                targets.removeUnit(u)
        end)
        let target = targets.getRandomUnit()
        targets.destr()
        if target != null
            if orb.castRandomSpell(target)
                this.lastSpellCastTimestamp = this.elapsedLifetime

    function updateOrbAngles()
        //Calculate orb angles and set it
        angle orbOffset = angle((360 / orbs.size())*DEGTORAD)
        int i = 0
        for o in orbs
            angle indexOrbAngle = orbAngle + orbOffset * i.toReal()
            o.setPos(centerPos.offset2d(indexOrbAngle, portalRadius))
            o.setFacing(o.pos.angleTo2d(centerPos))
            i = i + 1

    function startPortalLoop()
        if channeledTime < MINIMUM_GROW_DURATION
            destroy this
        else
            portalActiveLoop = doPeriodicallyTimed(ORB_LOOP_INTERVAL, durationBuildup) portalLoop ->
                //Check for destruction conditions first before accessing any objects
                if (portalLoop.isLast())
                    destroy this
                else
                    portalLoopUpdate()

    function portalLoopUpdate()
        //Check time since last spell was cast and cast
        if (this.elapsedLifetime - this.lastSpellCastTimestamp >= this.spellIntervalCurrent)
            randomOrbCastSpell()
        elapsedLifetime += ORB_LOOP_INTERVAL
        orbAngle = angle(orbAngle.radians() + ORB_LOOP_INTERVAL * ORB_ANGULARSPEED_ACTIVE * DEGTORAD)
        updateOrbAngles()

    function isValidTarget(unit t) returns boolean
        return not t.isInvulnerable() and not t.isType(UNIT_TYPE_STRUCTURE) and t.isAlive() and IsUnitVisible(t, ownerUnit.getOwner())

    ondestroy
        orbs.forEach(o -> destroy o)
        destroy orbs

        if lightGateInstances.has(ownerUnit)
            if (lightGateInstances.get(ownerUnit) == this)
                lightGateInstances.remove(ownerUnit)

function onCast()
    var caster = GetSpellAbilityUnit()

    //Destroy previous instance
    if lightGateInstances.has(caster)
        var prev_instance = lightGateInstances.get(caster)
        if prev_instance.portalActiveLoop != null
            prev_instance.portalActiveLoop.stop()
        if prev_instance.portalActiveLoop != null
            prev_instance.portalActiveLoop.stop()

    //Spawn the portal, a bit higher than the caster on Z axis
    lightGateInstances.put(caster, new LightGateInstance(caster, caster.getPos3Real() + vec3(0, 0, 50)))

function onEndCast()
    if GetSpellAbilityId() == ABILITY_ID
        var caster = GetSpellAbilityUnit()
        var instance = lightGateInstances.get(caster)
        instance.isChanneling = false

function initSpellPool()
    spellPool.add(1, new OrbSpell("Healing wave", 'XPHW', Orders.healingwave, 0))
    spellPool.add(1, new OrbSpell("Spirit link", 'Aspl', Orders.spiritlink, 'Bspl'))
    spellPool.add(2, new OrbSpell("Ranged heal", 'XPRH', Orders.heal, 0))
    spellPool.add(2, new OrbSpell("Pump up", 'A01U', Orders.bloodlust, 'B00O'))
    spellPool.add(2, new OrbSpell("Inner fire", 'Ainf', Orders.innerfire, 'BHds'))

init
    initSpellPool()
    registerSpellEffectEvent(ABILITY_ID, () -> onCast())
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onEndCast())
