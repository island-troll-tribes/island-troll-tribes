package StatLoss

// Standard library imports:
import ClosureTimers
import DamageEvent

// Local imports:
import Experience
import Game
import GameConfig
import TrollGroup
import ItemExtensions
import LocalObjectIDs
import UnitExtensions
import UnitUtils

constant BUFF_FROZE_TO_BONE_ID = BUFF_FROZE_TO_BONE

function checkStatDeath(unit target)
    // Exit if no work is required.
    if not target.isAlive() or (target.getMana() >= 1 and target.getHeat() >= 1)
        return

    // Find the nearest enemy troll.
    let killer = findNearestUnit(target.getPos(), expRange) (nearby) ->
        return nearby.isTroll() and not target.isAllyOf(nearby)

    // Have the enemy kill the target, defaulting to a suicide.
    DamageEvent.setNextDamageFromCode()
    (killer == null ? target : killer).damageTarget(target, target.getHP())

init
    registerGameStartEvent() ->
        let lossAmount = gameConfig.getStatLossAmount()
        let maxHeat = gameConfig.getMaxHeat()

        doPeriodically(gameConfig.getStatGainInterval()) cb ->
            for troll in getTrolls()
                let owner = troll.getOwner()
                var heat = owner.getGold()

                if GetTimeOfDay() >= 6 and GetTimeOfDay() <= 18
                    heat += 3

                if troll.hasAbility(BUFF_THE_GLOW)
                    heat += 2

                for i = 0 to troll.inventorySize() - 1
                    let gear = troll.itemInSlot(i)
                    if gear.isCoat()
                        heat += 5
                    else if gear.isBoots() or gear.isGloves()
                        heat += 2
                    else if gear.getTypeId() == ITEM_DD_PINION_FIRE
                        heat += 8

                owner.setGold(min(maxHeat, heat))

        doPeriodically(gameConfig.getStatLossInterval()) cb ->
            for troll in getTrolls()
                var heatLoss = lossAmount
                var energyLoss = lossAmount
                var healthLoss = lossAmount

                if troll.hasAbility(BUFF_CAMOFLAGE)
                    heatLoss *= 3
                    energyLoss *= 3
                    healthLoss *= 3

                if troll.hasAbility(BUFF_BON_FIRE_HEAT)
                    heatLoss -= 2

                if troll.hasAbility(BUFF_FROZE_TO_BONE_ID)
                    heatLoss += GetRandomInt(1, 5)

                let numStacksOfDepression = (
                    troll.hasAbility(BUFF_DEPRESSED_AURA).toInt() +
                    troll.hasAbility(BUFF_DEPRESSED_ARROW).toInt() +
                    troll.hasAbility(BUFF_DEPRESSED_THISTLE).toInt()
                )

                for i = 1 to numStacksOfDepression
                    energyLoss += GetRandomInt(1, 3)

                if numStacksOfDepression > 1
                    energyLoss += GetRandomInt(1, 6)
                    if numStacksOfDepression > 2
                        energyLoss += GetRandomInt(1, 6) + GetRandomInt(1, 6)

                // Mark the damage as coming from an internal system.
                DamageEvent.setNextDamageFromCode()

                // Update the state.
                troll.subHeat(heatLoss)
                troll.subMana(energyLoss.toReal())

                // Avoid waking the unit.
                // TODO: This only used as a workaround. Locking a unit via
                // sleep or stun should be simulated using an order listener to
                // ignore orders or BlzPauseUnitEx and then this check can be
                // removed.
                if not troll.isType(UNIT_TYPE_SLEEPING)
                    DamageEvent.setNextDamageFromCode()
                    troll.damageTarget(troll, healthLoss.toReal())

    // Kill units reaching zero in a stat as quickly as possible.
    doPeriodically(ANIMATION_PERIOD) (cb) ->
        for target in getTrolls()
            checkStatDeath(target)
