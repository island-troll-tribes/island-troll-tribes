package DementiaRunesNew
import RegisterEvents
import LinkedList
import ClosureTimers
import HashMap

@configurable constant int NEL_ABILITY_ID = 'A06S'
@configurable constant int KA_ABILITY_ID = 'A079'
@configurable constant int LEZ_ABILITY_ID = 'A07A'
@configurable constant real LOOP_INTERVAL = 0.03125
@configurable constant real ORBIT_ANGULARSPEED = 50
@configurable constant real ORBIT_DISTANCE = 275
@configurable constant int MAX_RUNE_COUNT = 5

@configurable constant string RUNE_EFFECT_PATH = ""

let dementiaRunesInstances = new HashMap<unit, DementiaRunesInstance>()

enum RUNE_TYPE
    Nel
    Lez
    Ka
    None

class DementiaRune
    DementiaRunesInstance instance
    effect FX = null
    vec3 pos

    construct (DementiaRunesInstance instance)
        pos = instance.ownerUnit.getPos3Real()
        FX = addEffect(RUNE_EFFECT_PATH, pos)

    function setPos(vec3 newpos)
        pos = newpos
        //Adjust orbs a little lower since the SFX looks like its higher
        FX.setPos(pos - vec3(0,0,75))

    ondestroy
        instance.runes.remove(this)
        FX.destr()

class DementiaRunesInstance
    angle runeAngleBase
    unit ownerUnit
    real elapsedLifetime
    CallbackPeriodic runeLoop = null

    LinkedList<DementiaRune> runes = new LinkedList<DementiaRune>()

    construct (unit caster)
        ownerUnit = caster
        elapsedLifetime = 0
        runeAngleBase = angle(0)
        startRuneLoop()

    function startRuneLoop()
        runeLoop = doPeriodically(LOOP_INTERVAL) runeUpdateLoop ->
            if ownerUnit.isAlive()
                elapsedLifetime += LOOP_INTERVAL
                runeAngleBase = angle(runeAngleBase.radians() + LOOP_INTERVAL * ORBIT_ANGULARSPEED * DEGTORAD)
                updateRunePositions()
            else
                destroy this
    
    function updateRunePositions()
        //Calculate orb angles and set it
        angle offset = angle((360 / runes.size())*DEGTORAD)
        int i = 0
        vec3 ownerpos = ownerUnit.getPos3Real()
        for r in runes
            angle indexRuneAngle = runeAngleBase + offset * i.toReal()
            r.setPos(ownerpos.offset2d(indexRuneAngle, ORBIT_DISTANCE))
            i = i + 1

    function addRune(DementiaRune rune)
        runes.add(rune)

    ondestroy
        destroy runeLoop

        runes.forEach(r -> destroy r)
        destroy runes

        if dementiaRunesInstances.has(ownerUnit)
            if (dementiaRunesInstances.get(ownerUnit) == this) 
                dementiaRunesInstances.remove(ownerUnit)


function onCast()
    var caster = GetSpellAbilityUnit()
    var ID = GetSpellAbilityId()
    RUNE_TYPE runeType = RUNE_TYPE.None

    if ID == NEL_ABILITY_ID
        runeType = RUNE_TYPE.Nel
    else if ID == LEZ_ABILITY_ID
        runeType = RUNE_TYPE.Lez
    else if ID == KA_ABILITY_ID
        runeType = RUNE_TYPE.Ka

    
    if dementiaRunesInstances.has(caster)
        //If caster has instance, add rune
        var instance = dementiaRunesInstances.get(caster)
        instance.addRune(new DementiaRune(instance))
    else
        //If caster has no instance, create one
        var instance = new DementiaRunesInstance(caster)
        dementiaRunesInstances.put(caster, instance)
        instance.addRune(new DementiaRune(instance))

init
    registerSpellEffectEvent(NEL_ABILITY_ID, () -> onCast())
    registerSpellEffectEvent(KA_ABILITY_ID, () -> onCast())
    registerSpellEffectEvent(LEZ_ABILITY_ID, () -> onCast())
