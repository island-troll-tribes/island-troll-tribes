package ResourceSpawns

import Assets
import HashMap
import LinkedList
import Pool
import SyncSimple

import Composer
import Lodash
import LocalObjectIDs
import ResourceSpawnsUtils
import BushSpawns
import GameConfig

import ClosureEvents
import Game
import OnUnitEnterLeave
import Toolkit

import ColorUtils
import ClosureTimers
import LocalAssets
import StringExtensions
import TerrainUtils

// The interval between sets of spawns in the same increment used to avoid lag.
let INTERVAL = 5.

// The delay between individual spawns used to avoid lag.
let DELAY = ANIMATION_PERIOD * 2

// Create the parameters for the various spawn rates. Islands as a whole are
// balanced against each other based on relative size and the same logic is
// applied to balance the internal regions against each other.
let islandInfos = new LinkedList<IslandInfo>
    ..add(
        new IslandInfo(15, 4, new Pool<rect>()
            ..add(65, gg_rct_spawn_area_1_1)
            ..add(22, gg_rct_spawn_area_1_2)
            ..add(13, gg_rct_spawn_area_1_3)
        )
    )
    ..add(
        new IslandInfo(16, 4, new Pool<rect>()
            ..add(66, gg_rct_spawn_area_2_1)
            ..add(16, gg_rct_spawn_area_2_2)
            ..add(18, gg_rct_spawn_area_2_3)
        )
    )
    ..add(
        new IslandInfo(16, 4, new Pool<rect>()
            ..add(54, gg_rct_spawn_area_3_1)
            ..add(13, gg_rct_spawn_area_3_2)
            ..add(33, gg_rct_spawn_area_3_3)
        )
    )
    ..add(
        new IslandInfo(23, 6, new Pool<rect>()
            ..add(88, gg_rct_spawn_area_4_1)
            ..add(7, gg_rct_spawn_area_4_2)
            ..add(8, gg_rct_spawn_area_4_3)
        )
    )

let itemSpawnInfoMap = new OwnedIterableMap<int, WeightScaler>()
    ..put(ITEM_TINDER,       new WeightScaler(450,  90,  860))
    ..put(ITEM_CLAY_BALL,    new WeightScaler(100, 185, 3600))
    ..put(ITEM_STICK,        new WeightScaler(300, 450,  360))
    ..put(ITEM_FLINT,        new WeightScaler(300, 250,  300))
    ..put(ITEM_MANA_CRYSTAL, new WeightScaler(  0, 160,  420))
    ..put(ITEM_MUSHROOM,     new WeightScaler(  0, 120,  360))
    ..put(ITEM_MAGIC,        new WeightScaler( 25,  25,    1))

let animalSpawnInfoMap = new OwnedIterableMap<int, WeightScaler>()
    ..put(UNIT_ELK,         new WeightScaler(1000, 1000,   0))
    ..put(UNIT_SNAKE,       new WeightScaler(   0,   45, 240))
    ..put(UNIT_JUNGLE_WOLF, new WeightScaler(   0,   90, 240))
    ..put(UNIT_JUNGLE_BEAR, new WeightScaler(   0,   45, 240))
    ..put(UNIT_PANTHER,     new WeightScaler(   0,   45, 240))

let fishSpawnInfoMap = new Pool<int>()
    ..add(4, UNIT_HAWK)
    ..add(2, UNIT_GREEN_FISH)
    ..add(4, UNIT_FISH)

// The current number of spawns of each type.
var currentFishes = 0
var currentAnimals = 0
var currentItems = 0

// The number of units to spawn per aquatic region.
let FISH_PER_AREA = 1

let fishSpawnRects = new OwnedLinkedList<rect>()
    ..add(gg_rct_out_1_1)
    ..add(gg_rct_out_3_2)
    ..add(gg_rct_out_1_2)
    ..add(gg_rct_out_5_2)
    ..add(gg_rct_out_2_2)
    ..add(gg_rct_out_3_1)
    ..add(gg_rct_out_4_1)
    ..add(gg_rct_out_4_2)
    ..add(gg_rct_our_5_1)
    ..add(gg_rct_out_2_1)
    ..add(gg_rct_fish_new_2)
    ..add(gg_rct_fish_new_3)
    ..add(gg_rct_fish_new_1)
    ..add(gg_rct_fish_new_4)
    ..add(gg_rct_fish_new_6)
    ..add(gg_rct_fish_new_5)
    ..add(gg_rct_fish_new_7)
    ..add(gg_rct_fish_new_8)

let spawnRegion = CreateRegion()
    ..addRect(gg_rct_spawn_area_1_1)
    ..addRect(gg_rct_spawn_area_1_2)
    ..addRect(gg_rct_spawn_area_1_3)
    ..addRect(gg_rct_spawn_area_2_1)
    ..addRect(gg_rct_spawn_area_2_2)
    ..addRect(gg_rct_spawn_area_2_3)
    ..addRect(gg_rct_spawn_area_3_1)
    ..addRect(gg_rct_spawn_area_3_2)
    ..addRect(gg_rct_spawn_area_3_3)
    ..addRect(gg_rct_spawn_area_4_1)
    ..addRect(gg_rct_spawn_area_4_2)
    ..addRect(gg_rct_spawn_area_4_3)

let restrainedSpawnRegion = CreateRegion()
    ..addRect(gg_rct_Thief_Bush_Cliff_SE)
    ..addRect(gg_rct_Thief_Bush_Cliff_NE)
    ..addRect(gg_rct_Thief_Bush_Cliff_SW_1)
    ..addRect(gg_rct_Thief_Bush_Cliff_SW_2)
    ..addRect(gg_rct_Thief_Bush_Cliff_NW)

function initFishSpawner() returns EmptyVoidFunction
    // Create an action per spawning region.
    return fishSpawnRects.foldl(new Composer()) (rect_, composer) ->
        // Add an action for that region to spawn a unit.
        return composer
            // Halt spawning if the population is at capacity.
            ..condition(-> currentFishes < gameConfig.getFishMax())
            // Spawn a unit.
            ..action(new FishSpawner(fishSpawnInfoMap, rect_))
            // Loop through the regions repeatedly
            ..repeat(FISH_PER_AREA)
            // Space out the spawns to avoid lag.
            ..period(DELAY)


function initItemSpawner() returns EmptyVoidFunction
    // Create an action per island.
    return islandInfos.foldl(new Composer()) (island, composer) ->
        // Create an item pool for the island.
        let pool = new ItemPool(itemSpawnInfoMap, island.numItems)

        // Add an action to perform spawning for that island.
        return composer
            // Update the item pool prior to spawning.
            ..action(-> pool.increment())
            // Use a nested composer to loop through repeated spawning.
            ..action(
                new Composer()
                    // Halt spawning if the population is at capacity.
                    ..condition(-> currentItems < gameConfig.getItemMax())
                    // Increment the population globally to reflect the spawn.
                    ..action(-> modifyItemCount(1))
                    // Spawn an item.
                    ..action(
                        new ItemSpawner(
                            pool,
                            island.regions,
                            restrainedSpawnRegion
                        )
                    )
                    // Spawn the appropriate amount of items in total.
                    ..repeat(-> (island.numItems * gameConfig.getItemBase()).ceil())
                    // Space out the spawns to avoid lag.
                    ..period(DELAY)
            )

function initAnimalSpawner() returns EmptyVoidFunction
    // Create an action per island.
    return islandInfos.foldl(new Composer()) (island, composer) ->
        // Create a unit pool for the island.
        let pool = new WeightedPool(animalSpawnInfoMap)

        // Add an action to perform spawning for that island.
        return composer
            // Update the item pool prior to spawning.
            ..action(-> pool.update())
            // Use a nested composer to loop through repeated spawning.
            ..action(
                new Composer()
                    // Halt spawning if the population is at capacity.
                    ..condition(-> currentAnimals < gameConfig.getMaxAnimals())
                    // Spawn an item.s
                    ..action(
                        new AnimalSpawner(
                            pool,
                            island.regions,
                            restrainedSpawnRegion
                        )
                    )
                    // Spawn the appropriate amount of units in total.
                    ..repeat(-> (island.numUnits * gameConfig.getFoodBase()).ceil())
                    // Space out the spawns to avoid lag.
                    ..period(DELAY)
            )

// Handles adjusting the total amount for items, which is done manually because
// there is no event able to intercept an item being created or removed.
public function modifyItemCount(int delta)
    currentItems += delta


// Handles adjusting the total amount for units.
function bookkeep(int delta, unit u)
    // Ignore units for players.
    if u.getOwner() != players[PLAYER_NEUTRAL_AGGRESSIVE]
        return

    // Increment the state if it is an animal.
    if animalSpawnInfoMap.has(u.getTypeId())
        currentAnimals += delta

    // Increment the state if it is a fish.
    if fishSpawnInfoMap.options.has(u.getTypeId())
        currentFishes += delta

// Decreases the total spawn rates as the game progresses.
function adjustBaseSpawnrates()
    gameConfig.setItemBase(max(.15, gameConfig.getItemBase() - 0.2))
    gameConfig.setFoodBase(max(.15, gameConfig.getFoodBase() - 0.3))

bool array debug_status

// Debugs a spawn point while testing.
function debugSpawnPoint(player player_, vec2 target)
    // Check the validity of the target.
    // TODO: Use the same function and inputs for this and the spawning.
    let validity = (
        target.isTerrainLand()
        and target.isTerrainWalkable()
        and target.isInRegion(spawnRegion)
        and not target.isInRegion(restrainedSpawnRegion)
    )

    // Color code the result.
    let resultColor = validity ? COLOR_GREEN : COLOR_RED

    // Create an effect to indicate the point that was selected.
    let effect_ = addEffect(Doodads.glowingRunes2, target)
        ..setColor(resultColor)

    // Destroy the effect afterwards.
    doAfter(4.5) ->
        effect_.destr()

    // Notify the user of the result.
    player_.print(
        "The point located at {0} is valid for spawning: {1}.".format(
            target.toString().color(SPECIAL_COLOR),
            validity.toString().color(resultColor)
        ),
        15
    )

init
    // Begin spawning when the gameplay starts.
    registerGameStartEvent() ->
        // Construct the spawning function per type.
        let animalSpawner = initAnimalSpawner()
        let fishSpawner = initFishSpawner()
        let itemSpawner = initItemSpawner()

        // Schedule the initial spawns, which vary in reptitions.
        doAfter(INTERVAL * 0, -> animalSpawner.call())
        doAfter(INTERVAL * 1, -> animalSpawner.call())
        doAfter(INTERVAL * 2, -> animalSpawner.call())
        doAfter(INTERVAL * 3, -> itemSpawner.call())
        doAfter(INTERVAL * 4, -> itemSpawner.call())
        doAfter(INTERVAL * 5, -> fishSpawner.call())
        doAfter(INTERVAL * 6, -> addItemsToBushes())

        // Schedule the periodic unit and item spawns.
        doPeriodically(120) spawnerCallback ->
            doAfter(INTERVAL * 0, -> animalSpawner.call())
            doAfter(INTERVAL * 1, -> itemSpawner.call())
            // Schedule the adjustment after the spawning begins to ensure that
            // the rates aren't adjusted prior to the spawning count computation
            doAfter(INTERVAL * 2, -> adjustBaseSpawnrates())

        // Schedule the periodic fish and bush spawns.
        doPeriodically(240) fishHawkCallback ->
            // Avoid scheduling these at the same time of the above.
            doAfter(INTERVAL * 2, -> addItemsToBushes())
            doAfter(INTERVAL * 3, -> fishSpawner.call())

    // Keep track of the totals for units.
    onLeave(() -> bookkeep(-1, getEnterLeaveUnit()))
    onEnter(() -> bookkeep( 1, getEnterLeaveUnit()))

    // Prints the current bookkeeping for spawns.
    registerToolkitCommand("sbk") (triggerer, arguments) ->
        triggerer.print(
            "There are currently {0} animals, {1} fish + hawks and {2} items in game"
                .format(
                    currentAnimals.toString(),
                    currentFishes.toString(),
                    currentItems.toString()
                )
                .color(GENERAL_COLOR),
            10
        )

    // SP for spawning point, Debugging which spot can spawn items
    registerToolkitCommand("sp") (triggerer, arguments) ->
        // Look up the index for the triggering player.
        let index = triggerer.getId()

        // Flip their status, which is initially disabled.
        debug_status[index] = not debug_status[index]

        // Notify them of the new status.
        if debug_status[index]
            triggerer.print(
                "Enabled debug mode for spawning points - click on a point to debug.".color(GENERAL_COLOR),
                10
            )
        else
            triggerer.print(
                "Spawning point debug mode disabled".color(GENERAL_COLOR),
                10
            )

    // Register the appropriate event handler if debugging spawn points is allowed.
    registerToolkitEvent() ->
        EventListener.add(EVENT_PLAYER_MOUSE_DOWN) ->
            // Capture the event parameters.
            let triggerer = EventData.getTriggerPlayer()
            let point = EventData.getMouseWorldPos()

            // Ignore events if debugging is not enabled.
            if debug_status[triggerer.getId()]
                // Sync the mouse position.
                point.sync(triggerer) point ->
                    // Debug once the state is synced.
                    debugSpawnPoint(triggerer, point)

// Syncs arbitrary data given convertions to and from string.
public function T.sync<T>(
    player p,
    Function<T, string> toString,
    Function<string, T> fromString,
    VoidFunction<T> listener
)
    toString.call(this).sync(p) data ->
        listener.call(fromString.call(data))
        destroy toString
        destroy fromString
        destroy listener

// Create an interface directly for vec2, which can't be used in a generic.
public interface Vec2SyncListener
    function onDataSynced(vec2 data)

function vec2.sync(player p, Vec2SyncListener listener)
    this.x.sync(p) x ->
        this.y.sync(p) y ->
            listener.onDataSynced(vec2(x, y))
