package SEFNew
import RegisterEvents
import HashMap
import LinkedList
import ClosureForGroups
import ClosureTimers
import AbilityObjEditing


@configurable constant int ABILITY_ID = 'ESEF'
@configurable constant real COOLDOWN = 10
@configurable constant int MANACOST = 10
@configurable constant real ORB_ATTACK_RADIUS = 575
@configurable constant real ORB_DAMAGE = 20
@configurable constant real ORB_ATTACK_COOLDOWN = 0.3
@configurable constant real ORB_IMPACT_DAMAGE = 10
@configurable constant real ORB_LIFETIME = 20
@configurable constant real ORB_SPEED = 550
@configurable constant real ORB_SPAWN_INTERVAL = 0.45
@configurable constant real CHANNEL_DURATION = 0.45*7 //7 Projectiles
@configurable constant real ORB_PERIODICINTERVAL_SPAWN = 0.05
@configurable constant real ORB_PERIODICINTERVAL_LOOP = 0.03125
@configurable constant real ORB_ANGULARORBITSPEED = 80 
@configurable constant real ORB_ORBIT_RADIUS = 175 
@configurable constant real ORB_ORBIT_HEIGHT = 150
@configurable constant string SPELL_ICON = "ReplaceableTextures\\CommandButtons\\BTNDispelMagic.blp"
@configurable constant string TOOLTIP_NORM = "R - Channel"
@configurable constant string TOOLTIP_EXT = "Conjures orbs to circle around you that fly to strike nearby enemies for 20 damage."
@configurable constant string ORB_EFFECT_PATH = "Abilities\\Weapons\\GreenDragonMissile\\GreenDragonMissile.mdl" 
@configurable constant string ORB_IMPACT_EFFECT = "Objects\\Spawnmodels\\NightElf\\EntBirthTarget\\EntBirthTarget.mdl" 

@compiletime function createSpell()
    new AbilityDefinitionIllidanChannel(ABILITY_ID)
    ..setTargetType(1, 0)
    ..setAnimationNames("spell,channel")
    ..setArtCaster("")
    ..setArtEffect("")
    ..setArtTarget("")
    ..setArtSpecial("")
    ..setButtonPositionNormalX(3)
    ..setButtonPositionNormalY(0)
    ..setIconNormal(SPELL_ICON)
    ..setIconResearch(SPELL_ICON)
    ..setIconTurnOff(SPELL_ICON)
    ..setHeroAbility(false)
    ..setItemAbility(false)
    ..setLevels(1)
    ..setHotkeyNormal("R")
    ..setName("Storm, Earth and Fire")
    ..setDisableOtherAbilities(1, false)
    ..setFollowThroughTime(1, CHANNEL_DURATION)
    ..setTooltipNormal(1, TOOLTIP_NORM)
    ..setTooltipNormalExtended(1, TOOLTIP_EXT)
    ..setBaseOrderID(1, "rechargeoff")
    ..setOptions(1, 1)
    ..setCooldown(1, COOLDOWN)
    ..setManaCost(1, MANACOST)

class SEFOrb
    SEFInstance instance
    unit ownerunit = null
    real speed = ORB_SPEED
    effect projectile = null
    vec3 target_pos
    unit target_unit = null

    construct (unit owner, SEFInstance SEF, vec3 startPos)
        ownerunit = owner
        instance = SEF
        projectile = addEffect(ORB_EFFECT_PATH, startPos)
        projectile.setScale(0.3)
        projectile.setColor(0, 255, 0)

    function moveTowardsTarget()
        //Update target location to targeted unit if its alive
        if (target_unit != null)
            if (target_unit.isAlive())
                target_pos = target_unit.getPos3Real()

        //Limit movement by speed
        var oldpos = projectile.getPos3()
        vec3 newpos
        if (oldpos.distanceTo(target_pos) <= ORB_SPEED * ORB_PERIODICINTERVAL_SPAWN)
            newpos = target_pos
            if (target_unit != null)
                onImpactEffect()
        else
            newpos = oldpos + oldpos.normalizedPointerTo(target_pos) * ORB_SPEED * ORB_PERIODICINTERVAL_SPAWN

        projectile.setPos(newpos)

    function findTarget()
        var curPos = projectile.getPos()
        if (target_unit == null)
            forUnitsInRange(curPos, ORB_ATTACK_RADIUS) u ->
                if (not u.isHidden() and u.isAlive() and not u.isInvulnerable() and u.getOwner().isEnemyOf(ownerunit.getOwner()))
                    //Get the closest unit if multiples happen to come into range at once
                    if (target_unit != null)
                        if (curPos.distanceTo( target_unit.getPos() ) > curPos.distanceTo(u.getPos()))
                            target_unit = u
                    else
                        target_unit = u
                    
    function updateLoop()
        if (target_unit == null)
            findTarget()
            moveTowardsTarget()
        else
            moveTowardsTarget()
        
    function onImpactEffect()
        ownerunit.damageTarget(target_unit, ORB_IMPACT_DAMAGE)
        var efx = addEffect(ORB_IMPACT_EFFECT, projectile.getPos3())
        efx.setScale(1)
        efx.setColor(0, 255, 0)
        doAfter(3) ->
            efx.destr()
        destroy this


    ondestroy
        instance.orbs.remove(this)
        projectile.destr()


class SEFInstance
    angle orbAngle
    unit ownerUnit
    bool isChanneling = true
    LinkedList<SEFOrb> orbs = new LinkedList<SEFOrb>()

    construct (unit caster)
        ownerUnit = caster
        real channel_time = 0
        real lastorb_created = 0
        real orb_interval = ORB_SPAWN_INTERVAL
        int i = 0
        doPeriodicallyTimed(ORB_PERIODICINTERVAL_SPAWN, CHANNEL_DURATION) cb ->
            if (isChanneling)
                channel_time = channel_time + ORB_PERIODICINTERVAL_SPAWN
                //Avoid floating point errors in the interval check with the -0.01
                if (channel_time - lastorb_created >= orb_interval-0.01)
                    orbs.push(new SEFOrb(ownerUnit, this, caster.getPos().withTerrainZ(ORB_ORBIT_HEIGHT)))
                    lastorb_created = channel_time
                    i = i + 1     
        this.startOrbLoop()


    function startOrbLoop()
        orbAngle = angle(0)

        doPeriodicallyTimed(ORB_PERIODICINTERVAL_LOOP, ORB_LIFETIME) orbLoop ->
            orbAngle = angle(orbAngle.radians() + ORB_PERIODICINTERVAL_LOOP * ORB_ANGULARORBITSPEED * DEGTORAD)
            
            int orbsWithoutTarget = 0

            for o in orbs
                if (o.target_unit == null)
                    orbsWithoutTarget += 1

            angle orbOffset = angle(bj_PI/4)
            if (orbsWithoutTarget != 0)
                orbOffset = angle(2 * bj_PI / orbsWithoutTarget )

            int i = 0
            
            for o in orbs
                angle indexOrbAngle = orbAngle + orbOffset * i.toReal()
                if (o.target_unit == null)
                    o.target_pos = ownerUnit.getPos().withTerrainZ(ORB_ORBIT_HEIGHT).offset2d(indexOrbAngle, ORB_ORBIT_RADIUS)
                o.updateLoop()
                i = i + 1


            if (orbLoop.isLast() or (orbs.size() == 0 and not isChanneling))
                orbLoop.stop()
                instances.remove(ownerUnit)
                destroy this


    ondestroy
        orbs.forEach(o -> destroy o)



let instances = new HashMap<unit, SEFInstance>()

function onCast()
    var caster = GetSpellAbilityUnit()

    if instances.has(caster)
        destroy instances.getAndRemove(caster)

    var SEF = new SEFInstance(caster)
    instances.put(caster, SEF)




function onEndCast()
    if GetSpellAbilityId() == ABILITY_ID
        var caster = GetSpellAbilityUnit()
        var instance = instances.get(caster)
        instance.isChanneling = false

init
    registerSpellEffectEvent(ABILITY_ID, () -> onCast())
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_ENDCAST, () -> onEndCast())