package ResourceSpawns

import HashMap
import LinkedList
import Pool

import Composer
import Lodash
import LocalObjectIDs
import ResourceSpawnsUtils
import BushSpawns
import GameConfig

import ClosureEvents
import Game
import OnUnitEnterLeave
import Toolkit

import ColorUtils
import ClosureTimers
import LocalAssets
import StringExtensions
import TerrainUtils

// I think this is to reduce lag
let delayPeriod = ANIMATION_PERIOD * 2

let islandInfos = initIslandInfo()

let itemSpawnInfoMap = new IterableMap<int, WeightScaler>()
    ..put(ITEM_TINDER, new WeightScaler(450, 90, 860))
    ..put(ITEM_CLAY_BALL, new WeightScaler(100, 185, 3600))
    ..put(ITEM_STICK, new WeightScaler(300, 450, 360))
    ..put(ITEM_FLINT, new WeightScaler(300, 250, 300))
    ..put(ITEM_MANA_CRYSTAL, new WeightScaler(0, 160, 420))
    ..put(ITEM_MUSHROOM, new WeightScaler(0, 120, 360))
    ..put(ITEM_MAGIC, new WeightScaler(25, 25, 1))

let animalSpawnInfoMap = new IterableMap<int, WeightScaler>()
    ..put(UNIT_ELK, new WeightScaler(1000, 1000, 0))
    ..put(UNIT_SNAKE, new WeightScaler(0, 45, 240))
    ..put(UNIT_JUNGLE_WOLF, new WeightScaler(0, 90, 240))
    ..put(UNIT_JUNGLE_BEAR, new WeightScaler(0, 45, 240))
    ..put(UNIT_PANTHER, new WeightScaler(0, 45, 240))

let fishSpawnInfoMap = new Pool<int>()
    ..add(4, UNIT_HAWK)
    ..add(2, UNIT_GREEN_FISH)
    ..add(4, UNIT_FISH)

// bookkeeper keys of spawninfos => current number of items spawned
var currentFishes = 0
var currentAnimals = 0
var currentItems = 0

let FISH_PER_AREA = 1

let fishSpawnRects = new LinkedList<rect>()
    ..add(gg_rct_out_1_1)
    ..add(gg_rct_out_3_2)
    ..add(gg_rct_out_1_2)
    ..add(gg_rct_out_5_2)
    ..add(gg_rct_out_2_2)
    ..add(gg_rct_out_3_1)
    ..add(gg_rct_out_4_1)
    ..add(gg_rct_out_4_2)
    ..add(gg_rct_our_5_1)
    ..add(gg_rct_out_2_1)
    ..add(gg_rct_fish_new_2)
    ..add(gg_rct_fish_new_3)
    ..add(gg_rct_fish_new_1)
    ..add(gg_rct_fish_new_4)
    ..add(gg_rct_fish_new_6)
    ..add(gg_rct_fish_new_5)
    ..add(gg_rct_fish_new_7)
    ..add(gg_rct_fish_new_8)

let spawnRegion = CreateRegion()
    ..addRect(gg_rct_spawn_area_1_1)
    ..addRect(gg_rct_spawn_area_1_2)
    ..addRect(gg_rct_spawn_area_1_3)
    ..addRect(gg_rct_spawn_area_2_1)
    ..addRect(gg_rct_spawn_area_2_2)
    ..addRect(gg_rct_spawn_area_2_3)
    ..addRect(gg_rct_spawn_area_3_1)
    ..addRect(gg_rct_spawn_area_3_2)
    ..addRect(gg_rct_spawn_area_3_3)
    ..addRect(gg_rct_spawn_area_4_1)
    ..addRect(gg_rct_spawn_area_4_2)
    ..addRect(gg_rct_spawn_area_4_3)

let restrainedSpawnRegion = CreateRegion()
    ..addRect(gg_rct_Thief_Bush_Cliff_SE)
    ..addRect(gg_rct_Thief_Bush_Cliff_NE)
    ..addRect(gg_rct_Thief_Bush_Cliff_SW_1)
    ..addRect(gg_rct_Thief_Bush_Cliff_SW_2)
    ..addRect(gg_rct_Thief_Bush_Cliff_NW)

let animalSpawner = initAnimalSpawner()
let itemSpawner = initItemSpawner()
let fishSpawner = initFishSpawner()

// From Marsunpaisti :
// this is the part that handles the island balance
// when I add those rects, the first number is the relative size of the region to all the other rects
// so all areas get picked evenly
// new IslandSpawner(23, 6, swSpawns) here the variables mean this island will get 23 items and 6 animals
// because SW is bigger than the others
function initIslandInfo() returns LinkedList<IslandInfo>
    return new LinkedList<IslandInfo>
        ..add(new IslandInfo(15, 4, new Pool<rect>()
            ..add(65, gg_rct_spawn_area_1_1)
            ..add(22, gg_rct_spawn_area_1_2)
            ..add(13, gg_rct_spawn_area_1_3))
        )
        ..add(new IslandInfo(16, 4, new Pool<rect>()
            ..add(66, gg_rct_spawn_area_2_1)
            ..add(16, gg_rct_spawn_area_2_2)
            ..add(18, gg_rct_spawn_area_2_3))
        )
        ..add(new IslandInfo(16, 4, new Pool<rect>()
            ..add(54, gg_rct_spawn_area_3_1)
            ..add(13, gg_rct_spawn_area_3_2)
            ..add(33, gg_rct_spawn_area_3_3))
        )
        ..add(new IslandInfo(23, 6, new Pool<rect>()
            ..add(88, gg_rct_spawn_area_4_1)
            ..add(7, gg_rct_spawn_area_4_2)
            ..add(8, gg_rct_spawn_area_4_3))
        )

function initFishSpawner() returns Spawner
    EmptyFunction<bool> condition = () -> currentFishes < udg_FISH_MAX

    let fishSpawners = new LinkedList<Composer>()
    for r in fishSpawnRects
        fishSpawners.add(
            new ConditionalComposer(
                condition,
                new FishSpawnComposer(fishSpawnInfoMap, r)
            )
        )
    
    return new Spawner(
        new StaggeredComposer(
            FISH_PER_AREA,
            delayPeriod,
            new MultipleComposer(fishSpawners)
        )
    )

function initItemSpawner() returns Spawner
    let itemPools = new LinkedList<ItemPool>()
    EmptyFunction<bool> condition = () ->
        let b = currentItems < udg_ITEM_MAX
        if b
            currentItems++ // Bookkeeping
        return b
    
    // Make one spawner per island and combine at the end
    let islandSpawners = new LinkedList<Composer>()
    for island in islandInfos
        let itemPool = new ItemPool(itemSpawnInfoMap, island.itemsSpawnCount)
        itemPools.add(itemPool)
        islandSpawners.add(
            new StaggeredComposer(
                (island.itemsSpawnCount * udg_ITEM_BASE).ceil(),
                delayPeriod,
                new ConditionalComposer(
                    condition,
                    new ItemSpawnComposer(itemPool, island.spawnRegionsPool, restrainedSpawnRegion)
                )
            )
        )

    // Update the pools before each execution
    EmptyFunction<bool> preAction = () ->
        for itemPool in itemPools
            itemPool.update()
        return true
    
    return new Spawner(
        new ConditionalComposer(
            preAction,
            new MultipleComposer(islandSpawners)
        )
    )

function initAnimalSpawner() returns Spawner
    let weightedPools = new LinkedList<WeightedPool<int>>()
    EmptyFunction<bool> condition = () -> (currentAnimals < gameConfig.getMaxAnimals())

    // Make one spawner per island and combine at the end
    let islandSpawners = new LinkedList<Composer>()
    for island in islandInfos
        let weightedPool = new WeightedPool(animalSpawnInfoMap)
        weightedPools.add(weightedPool)
        islandSpawners.add(
            new StaggeredComposer(
                (island.animalsSpawnCount * udg_FOOD_BASE).ceil(),
                delayPeriod,
                new ConditionalComposer(
                    condition,
                    new AnimalSpawnComposer(weightedPool, island.spawnRegionsPool, restrainedSpawnRegion)
                )
            )
        )

    // Update the pools before each execution
    EmptyFunction<bool> preAction = () ->
        for weightedPool in weightedPools
            weightedPool.update()
        return true
        
    return new Spawner(
        new ConditionalComposer(
            preAction,
            new MultipleComposer(islandSpawners)
        )
    )

// Bookkeeping
public function lowerItem(int count)
    currentItems -= count

function bookkeep(bool born, unit u)
    if u.getOwner() == players[PLAYER_NEUTRAL_AGGRESSIVE]
        if animalSpawnInfoMap.has(u.getTypeId())
            currentAnimals = born ? (currentAnimals + 1) : (currentAnimals - 1)
        
        if fishSpawnInfoMap.options.has(u.getTypeId())
            currentFishes = born ? (currentFishes + 1) : (currentFishes - 1)

// Spawn cycles
function adjustBaseSpawnrates()
    //Replacement for modStats function of the legacy system.
    //Dynamically adjust overall item & animal amounts (and specific item type amounts but thats handles by spawnInfo classes now)
    udg_ITEM_BASE = max(.15,udg_ITEM_BASE-0.2)
    udg_FOOD_BASE = max(.15,udg_FOOD_BASE-0.3)

function startSpawnCycle(Spawner animalSpawner, Spawner itemSpawner, Spawner fishSpawner)
    doPeriodically(120) spawnerCallback ->
        animalSpawner.spawn()
        doAfter(5) ->
            itemSpawner.spawn()
            adjustBaseSpawnrates()

    //Another loop because 1 spawned fish per area per 240 seconds is hard to cut in half
    doPeriodically(240) fishHawkCallback ->
        //Delays so these dont happen exactly at the same time as the 120 second interval actions
        doAfter(10, -> addItemsToBushes())
        doAfter(15, -> fishSpawner.spawn())

bool array debug_status

init
    registerGameStartEvent() ->
        //First spawns. Do twice to retain original amounts after halving the items per spawn and doubling cycle frequency.
        animalSpawner.spawn()
        doAfter(5, -> animalSpawner.spawn())
        doAfter(10, -> animalSpawner.spawn())
        doAfter(15, -> itemSpawner.spawn())
        doAfter(20, -> itemSpawner.spawn())
        doAfter(25, -> fishSpawner.spawn())
        doAfter(30, -> addItemsToBushes())
        startSpawnCycle(animalSpawner, itemSpawner, fishSpawner)

    // Keep track of animals/fishes
    onLeave(() -> bookkeep(false, getEnterLeaveUnit()))
    onEnter(() -> bookkeep(true, getEnterLeaveUnit()))

    registerToolkitCommand("sbk") (triggerPlayer, arguments) ->
        printTimedToPlayer("There are currently {0} animals, {1} fishes/hawks and {2} items in game".format(
            currentAnimals.toString(),
            currentFishes.toString(),
            currentItems.toString()
        ).color(GENERAL_COLOR), 10, triggerPlayer)
    
    // SP for spawning point, Debugging which spot can spawn items
    registerToolkitCommand("sp") (triggerPlayer, arguments) ->
        // Look up the index for the triggering player.
        let index = triggerPlayer.getId()
        if debug_status[index] == true
            printTimedToPlayer("Spawning point debug mode disabled".color(GENERAL_COLOR), 10, triggerPlayer)
            debug_status[index] = false
        else
            printTimedToPlayer("Spawning point debug mode enabled, click on a point to check if it's a valid spawning point for items/animals".color(GENERAL_COLOR), 10, triggerPlayer)
            debug_status[index] = true

        EventListener.add(EVENT_PLAYER_MOUSE_DOWN) ->
            let p = EventData.getTriggerPlayer()
            let point = EventData.getMouseWorldPos()

            if debug_status[p.getId()]
                let efx = addEffect(LocalAbilities.generalHeroGlow, point)..setScale(0.5)
                doAfter(4.5) ->
                    efx.destr()
                let msg = "The point located at " + point.toString().color(SPECIAL_COLOR) + " is a {0} spawning point."
                if point.isTerrainLand()
                    and point.isTerrainWalkable()
                    and point.isInRegion(spawnRegion)
                    and not point.isInRegion(restrainedSpawnRegion)
                    printTimedToPlayer(msg.format("valid".color(COLOR_GREEN)), 15, p)
                else
                    printTimedToPlayer(msg.format("invalid".color(COLOR_RED)), 15, p)
