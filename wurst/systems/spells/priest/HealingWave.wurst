package HealingWave

import RegisterEvents
import ClosureTimers
import AbilityObjEditing
import GroupExtensions
import Assets
import HealingSystem
import EffectUtils
import LinkedList
import MapBounds

constant let ABILITY_ID = 'XPHW'
constant let CAST_RANGE = 6000.
constant let BOUNCE_SEARCH_RANGE = 6000.
constant let COOLDOWN = 20.
constant let MANACOST = 10
constant let HEAL_AMOUNT = 50.
constant let HEAL_REDUCTION_BOUNCE_FACTOR = 0.1
constant let BOUNCE_COUNT = 7
constant let TOOLTIP_NORMAL = "|c00ffcc00D|r - Healing wave"
constant let TOOLTIP_NORMAL_EXT = "Calls forth a wave of healing energy that bounces up to 7 times, healing 50 damage on the primary target. Each jump heals 10% less. Bounces on an extremely large range."
constant let HEALING_WAVE_HIT_FX = "Abilities\\Spells\\Orc\\HealingWave\\HealingWaveTarget.mdl"
constant let HEAL_HIT_FX = "Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"

@compiletime function createSpell()
    new AbilityDefinitionIllidanChannel(ABILITY_ID)
    ..setButtonPositionNormalX(0)
    ..setButtonPositionNormalY(0)
    ..setButtonPositionResearchX(0)
    ..setButtonPositionResearchY(0)
    ..setArtTarget("")
    ..setArtCaster("")
    ..setArtSpecial("")
    ..presetCastRange(lvl -> CAST_RANGE)
    ..presetCastingTime(lvl -> 0)
    ..presetFollowThroughTime(lvl -> 0.275)
    ..presetCooldown(lvl -> COOLDOWN)
    ..presetManaCost(lvl -> MANACOST)
    ..presetTargetType(lvl -> 1)
    ..presetTargetsAllowed(lvl -> "air,ground,friend,self,vuln,invu,organic")
    ..presetOptions(lvl -> 1)
    ..presetDisableOtherAbilities(lvl -> false)
    ..setLevels(1)
    ..setHeroAbility(false)
    ..setItemAbility(false)
    ..setHotkeyNormal("D")
    ..setName("Healing Wave")
    ..presetTooltipNormal(lvl -> TOOLTIP_NORMAL)
    ..presetTooltipNormalExtended(lvl -> TOOLTIP_NORMAL_EXT)
    ..setIconNormal(Icons.bTNHealingWave)
    ..setIconResearch(Icons.bTNHealingWave)
    ..presetBaseOrderID(lvl -> "healingwave")
    ..setOrderStringActivate("healingwave")
    ..setOrderStringUseTurnOn("healingwave")

class HealingWaveInstance
    unit caster
    player owner
    int bouncesLeft
    real healingAmount
    LinkedList<unit> targetsHit = new LinkedList<unit>()

    construct(unit caster, unit target, real healingInitialAmount, int bounces)
        this.caster = caster
        this.healingAmount = healingInitialAmount
        this.bouncesLeft = bounces
        this.owner = caster.getOwner()
        waveBounce(target, caster, true)

    function waveBounce(unit target, unit previousTarget, bool isFirstBounce)
        var lightningFxPath = isFirstBounce ? LIGHTNING_HEALING_WAWE_PRIMARY : LIGHTNING_HEALING_WAWE_SEECONDARY

        new HealingInstance(target, this.healingAmount, HealingType.ABILITY)
        attachLightningFX(previousTarget, target, lightningFxPath, 1.5)
        let fx1 = addEffect(HEALING_WAVE_HIT_FX, target.getPos3Real())
        let fx2 = target.addEffect(HEAL_HIT_FX, "origin")
        doPeriodicallyTimed(ANIMATION_PERIOD, 1.5) fxUpdater ->
            fx1.setPos(target.getPos3Real())
            if fxUpdater.isLast()
                fx1.setPos(boundMax)
                fx1.destr()
                fx2.destr()

        this.healingAmount *= 1 - HEAL_REDUCTION_BOUNCE_FACTOR
        this.bouncesLeft -= 1
        this.targetsHit.add(target)

        if this.bouncesLeft > 0
            doAfter(0.3) ->
                let nextTarget = findBounceTarget(target)
                if nextTarget != null
                    waveBounce(nextTarget, target, false)
                else
                    destroy this
        else
            destroy this

    function findBounceTarget(unit bounceOrigin) returns unit
        unit found = null
        let units = CreateGroup()
            ..enumUnitsInRange(bounceOrigin.getPos(), BOUNCE_SEARCH_RANGE)

        for u in units
            if not isValidTarget(u)
                units.removeUnit(u)

        if units.size() > 0
            let unitsList = units.toLinkedList()
            unitsList.sortWith((a,b) -> (a.getPos().distanceToSq(bounceOrigin.getPos()) - b.getPos().distanceToSq(bounceOrigin.getPos())).round())
            found = unitsList.getFirst()
            destroy unitsList

        units.destr()
        return found

    function isValidTarget(unit target) returns bool
        return target.isAlive()
        and target.getOwner().isAllyOf(this.owner)
        and not target.isType(UNIT_TYPE_STRUCTURE)
        and not target.isType(UNIT_TYPE_MECHANICAL)
        and not targetsHit.has(target)
        and not target.getHP().round() == target.getMaxHP().round()

    ondestroy
        destroy this.targetsHit

init
    registerSpellEffectEvent(ABILITY_ID) ->
        var caster = GetSpellAbilityUnit()
        var target = GetSpellTargetUnit()
        new HealingWaveInstance(caster, target, HEAL_AMOUNT, BOUNCE_COUNT)

    /*
    registerCommandAll("hwave") (triggerPlayer, args) ->
        printTimed("Added healwave", 5)
        let units = CreateGroup()
            ..enumUnitsSelected(triggerPlayer, null)

        for u in units
            if u.isType(UNIT_TYPE_HERO)
                u.addAbility(ABILITY_ID)

        units.destr()
    */
